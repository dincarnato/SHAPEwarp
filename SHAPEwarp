#!/usr/bin/perl

use strict;
use FindBin qw($Bin);
use Getopt::Long qw(:config no_ignore_case);
use POSIX ();
use Storable;
use threads;
use threads::shared;

use lib $Bin . "/lib";

use Core::Mathematics qw(:all);
use Core::Process::Queue;
use Core::Statistics;
use Core::Utils;
use Graphics::Container;
use Graphics::Object::Barplot;
use Graphics::Object::RNAarcs;
use Graphics::Object::Ruler;
use Interface::ViennaRNA;
use RF::Data::IO::XML;
use RNA::Utils;
use SW::DB;
use SW::Align;
use SW::Utils;
use Term::Constants qw(:screen);
use Term::Progress;
use Term::Table;

$|++;

my ($help, $output, $overwrite, $dbFolder,
    $queryFile, $threads, $queryIO, $dbIO,
    $minKmers, $maxKmerDist, $matchKmerSeq,
    $kmerMaxSeqDist, $kmerLen, $kmerOffset,
    $kmerMinComplexity, $kmerMaxMatchEveryNt,
    $alignMatchScore, $alignMismatchScore,
    $alignGapOpenPenal, $alignGapExtPenal,
    $alignMaxDropOffRate, $alignMaxDropOffBases,
    $alignLenTolerance, $ignoreReact, $nullKmers,
    $maxReactivity, $maxAlignOverlap, $tblOut,
    $nAliShufflings, $foldQuery, $evalAlignFold,
    $alignFoldPvalue, $reportEvalue, $inclusionEvalue,
    $ribosumScoring, $blockSize, $inBlockShuffle,
    $minBpSupport, $makePlot, $reportAln, $alignScoreSeq,
    $alignSeqMatchScore, $alignSeqMismatchScore, $slope,
    $intercept, $matchKmerGCcontent, $maxKmerGCdiff,
    $maxBPspan, $noLonelyPairs, $noClosingGU, $temperature,
    $foldWin, $foldOffset, $winTrim, $pathToAlifold,
    @pool, @finalMatches);

my $progressBar : shared;
my $processedNullKmers : shared;
my @id : shared;

do {

    local $SIG{__WARN__} = sub { };

    GetOptions( "o|output=s"              => \$output,
                "ow|overwrite"            => \$overwrite,
                "db|database=s"           => \$dbFolder,
                "q|query=s"               => \$queryFile,
                "threads=i"               => \$threads,
                "makePlot"                => \$makePlot,
                "reportAln=s"             => \$reportAln,
                "minKmers=i"              => \$minKmers,
                "maxKmerDist=i"           => \$maxKmerDist,
                "matchKmerSeq"            => \$matchKmerSeq,
                "kmerMaxSeqDist=s"        => \$kmerMaxSeqDist,
                "matchKmerGCcontent"      => \$matchKmerGCcontent,
                "maxKmerGCdiff=s"         => \$maxKmerGCdiff,
                "kmerLen=i"               => \$kmerLen,
                "kmerOffset=i"            => \$kmerOffset,
                "kmerMinComplexity=s"     => \$kmerMinComplexity,
                "kmerMaxMatchEveryNt=i"   => \$kmerMaxMatchEveryNt,
                "nullKmers=i"             => \$nullKmers,
                "alignMatchScore=s"       => \$alignMatchScore,
                "alignMismatchScore=s"    => \$alignMismatchScore,
                "alignGapOpenPenal=s"     => \$alignGapOpenPenal,
                "alignGapExtPenal=s"      => \$alignGapExtPenal,
                "alignMaxDropOffRate=s"   => \$alignMaxDropOffRate,
                "alignMaxDropOffBases=i"  => \$alignMaxDropOffBases,
                "alignLenTolerance=s"     => \$alignLenTolerance,
                "alignScoreSeq"           => \$alignScoreSeq,
                "alignSeqMatchScore=s"    => \$alignSeqMatchScore,
                "alignSeqMismatchScore=s" => \$alignSeqMismatchScore,
                "maxReactivity=s"         => \$maxReactivity,
                "maxAlignOverlap=s"       => \$maxAlignOverlap,
                "foldQuery"               => \$foldQuery,
                "ignoreReact"             => \$ignoreReact,
                "slope=s"                 => \$slope,
                "intercept=s"             => \$intercept,
                "maxBPspan=i"             => \$maxBPspan,
                "noLonelyPairs"           => \$noLonelyPairs,
                "noClosingGU"             => \$noClosingGU,
                "temperature"             => \$temperature,
                "winSize=i"               => \$foldWin,
                "offset=i"                => \$foldOffset,
                "winTrim=i"               => \$winTrim,
                "evalAlignFold"           => \$evalAlignFold,
                "repE|reportEvalue=s"     => \$reportEvalue,
                "incE|inclusionEvalue=s"  => \$inclusionEvalue,
                "alignFoldPvalue=s"       => \$alignFoldPvalue,
                "minBpSupport=s"          => \$minBpSupport,
                "ribosumScoring"          => \$ribosumScoring,
                "blockSize=i"             => \$blockSize,
                "inBlockShuffle"          => \$inBlockShuffle,
                "tblOut"                  => \$tblOut,
                "RNAalifold=s"            => \$pathToAlifold ) or help(1);

};

help() if ($help);

$output ||= "sw_out/";
$threads ||= 1;
$minKmers ||= 2;
$maxKmerDist ||= 30;
$maxReactivity = 1.0;
$nullKmers ||= 10000;
$kmerMaxSeqDist //= 0;
$kmerLen ||= 15;
$kmerOffset ||= 1;
$kmerMinComplexity //= 0.3;
$kmerMaxMatchEveryNt //= 200;
$alignMatchScore ||= "-0.5,2";
$alignMismatchScore ||= "-6,-0.5";
$alignGapOpenPenal ||= -14;
$alignGapExtPenal ||= -5;
$alignMaxDropOffRate //= 0.8;
$alignMaxDropOffBases //= 8;
$alignLenTolerance //= 0.1;
$alignSeqMatchScore //= 0.5;
$alignSeqMismatchScore //= -2;
$maxAlignOverlap ||= 0.5;
$nAliShufflings ||= 100;
$alignFoldPvalue //= 0.05;
$reportEvalue //= 0.1;
$inclusionEvalue //= 0.01;
$minBpSupport //= 0.75;
$slope //= 1.8;
$intercept //= -0.6;
$temperature //= 37;
$maxBPspan //= 600;
$foldWin ||= 800;
$foldOffset ||= 200;
$winTrim //= 50;
$blockSize ||= 3;
$pathToAlifold ||= which("RNAalifold");

$output =~ s/\/?$/\//;
$dbFolder =~ s/\/?$/\//;
$alignMatchScore = [ sort { $a <=> $b } split(",", $alignMatchScore) ];
$alignMismatchScore = [ sort { $a <=> $b } split(",", $alignMismatchScore) ];
$progressBar = shareDataStruct(Term::Progress->new( max   => 0,
                                                    width => 50 ));

die "\n[!] Error: Database path does not point to a directory\n\n" if (!-d $dbFolder);
die "\n[!] Error: Database file reactivity.db is missing\n\n" if (!-e $dbFolder . "reactivity.db");
die "\n[!] Error: Database file reactivity.shuffled.db is missing\n\n" if (!-e $dbFolder . "reactivity.shuffled.db");
die "\n[!] Error: Invalid alignment format \"" . $reportAln . "\"\n\n" if (defined $reportAln && $reportAln !~ m/^(?:f(asta)?|s(tockholm)?)$/i);
die "\n[!] Error: No query file provided\n\n" if (!$queryFile);
die "\n[!] Error: Specified query file does not exist\n\n" if (!-e $queryFile);
die "\n[!] Error: Minimum number of kmers must be an INT > 0\n\n" if (!isint($minKmers) || $minKmers <= 0);
die "\n[!] Error: Maximum kmer distance must be a positive INT\n\n" if (!isint($maxKmerDist) || !ispositive($maxKmerDist));
die "\n[!] Error: Maximum kmer sequence distance must be positive\n\n" if (!ispositive($kmerMaxSeqDist));
die "\n[!] Error: Maximum kmer GC% difference must be positive\n\n" if (defined $maxKmerGCdiff && !ispositive($maxKmerGCdiff));
die "\n[!] Error: Kmer length must be a positive INT >= 6\n\n" if (!isint($kmerLen) || $kmerLen < 6);
die "\n[!] Error: Kmer offset must be a positive INT comprised between 1 and kmerLen\n\n" if (!isint($kmerOffset) || $kmerOffset <= 0 || $kmerOffset > $kmerLen);
die "\n[!] Error: Minimum kmer complexity must be a positive INT\n\n" if (!ispositive($kmerMinComplexity));
die "\n[!] Error: Number of null kmers to evaluate must be a positive INT >= 100\n\n" if (!isint($nullKmers) || $nullKmers < 100);
die "\n[!] Error: Alignment match score must be provided as a pair of comma-separated values\n\n" if (@{$alignMatchScore} != 2);
die "\n[!] Error: Alignment mismatch score must be provided as a pair of comma-separated values\n\n" if (@{$alignMismatchScore} != 2);
die "\n[!] Error: Alignment match score values must be numeric\n\n" if (!isnumeric(@{$alignMatchScore}));
die "\n[!] Error: Alignment mismatch score values must be numeric\n\n" if (!isnumeric(@{$alignMismatchScore}));
die "\n[!] Error: Alignment gap open penalty must be numeric\n\n" if (!isnumeric($alignGapOpenPenal));
die "\n[!] Error: Alignment gap extension penalty must be numeric\n\n" if (!isnumeric($alignGapExtPenal));
die "\n[!] Error: Alignment maximum drop-off rate must be a positive INT comprised between 0 and 1\n\n" if (!inrange($alignMaxDropOffRate, [0, 1]));
die "\n[!] Error: Alignment maximum drop-off bases must be a positive INT\n\n" if (!isint($alignMaxDropOffBases));
die "\n[!] Error: Alignment maximum tolerated length difference must be a positive INT comprised between 0 and 1\n\n" if (!inrange($alignLenTolerance, [0, 1]));
die "\n[!] Error: Alignment sequence match score must be numeric\n\n" if (!isnumeric($alignSeqMatchScore));
die "\n[!] Error: Alignment sequence mismatch score must be numeric\n\n" if (!isnumeric($alignSeqMismatchScore));
die "\n[!] Error: Maximum reactivity must be > 0\n\n" if (!ispositive($maxReactivity) || $maxReactivity == 0);
die "\n[!] Error: Maximum alignment overlap must be a positive INT comprised between 0 and 1\n\n" if (!inrange($maxAlignOverlap, [0, 1]));
die "\n[!] Error: Slope must be numeric\n\n" if (!isnumeric($slope));
die "\n[!] Error: Intercept must be numeric\n\n" if (!isnumeric($intercept));
die "\n[!] Error: Maximum base-pair span must be a positive INT >= 3\n\n" if (!ispositive($maxBPspan) || $maxBPspan < 3);
die "\n[!] Error: Temperature must be numeric\n\n" if (!isnumeric($temperature));
die "\n[!] Error: Folding window size must be an INT >= 50\n\n" if (!isint($foldWin) || $foldWin < 50);
die "\n[!] Error: Folding window sliding offset must be a positive INT comprised between 0 and winSize\n\n" if (!isint($foldOffset) || $foldOffset > $foldWin);
die "\n[!] Error: Window trimming must be a positive INT comprised between 0 and half the difference of winSize - offset\n\n" if (!isint($winTrim) || $winTrim > int(($foldWin - $foldOffset) / 2));
die "\n[!] Error: Reporting E-value cutoff must be positive\n\n" if (!ispositive($reportEvalue));
die "\n[!] Error: Inclusion E-value cutoff must be positive\n\n" if (!ispositive($inclusionEvalue));
die "\n[!] Error: Alignment folding p-value cutoff must be comprised between 0 and 1\n\n" if (!inrange($alignFoldPvalue, [0, 1]));
die "\n[!] Error: Minimum base-pair support must be comprised between 0 and 1\n\n" if (!inrange($minBpSupport, [0, 1]));
die "\n[!] Error: Block size must be a positive INT > 0\n\n" if (!isint($blockSize) || $blockSize <= 0);
die "\n[!] Error: RNAalifold is not in PATH\n\n" if ($evalAlignFold && !defined $pathToAlifold);
die "\n[!] Error: Provided path to RNAalifold does not point to an executable\n\n" if ($evalAlignFold && (!-e $pathToAlifold || !-x $pathToAlifold || !-f $pathToAlifold));

print "\n[+] Making output directory...";

if (-e $output) {

    if ($overwrite) {

        my $error = rmtree($output);

        die "\n\n  [!] Error: " . $error . "\n\n" if ($error);

    }
    else { die "\n\n  [!] Error: Output directory already exists." .
               "\n      Please use -ow (or --overwrite) to overwrite output directory\n\n"; }

}

mktree($output . "tmp/");
mktree($output . "images/") if ($makePlot);
mktree($output . "alignments/") if ($reportAln);

writeParamsOut();

$queryIO = Data::IO->new(file => $queryFile);
while(!$queryIO->eof()) {

    my ($queryId, $querySeq, $queryReact, $nullMean,
        $nullStdev, $nullModel, $nKmers, $n,
        $kmerLookupCmd, $ret, @pool, @kmers, @alignments, @matches);
    $queryId = $queryIO->read();

    next if (!length($queryId));

    print CLRTOP;

    $querySeq = $queryIO->read();
    $queryReact = $queryIO->read();
    $queryReact = $foldQuery && $ignoreReact ? [ ("NaN") x length($querySeq) ] : [ split(",", $queryReact) ];

    print "\n[!] Error: No sequence for query \"" . $queryId . "\"\n\n" and last if (!defined $querySeq);
    print "\n[!] Error: No reactivity for query \"" . $queryId . "\"\n\n" and last if (!@{$queryReact});
    print "\n[!] Error: Different lengths for sequence and reactivity for query \"" . $queryId . "\"\n\n" and last if (length($querySeq) != @{$queryReact});

    @{$queryReact} = unpairedProbs($querySeq, $queryReact, { slope         => $slope,
                                                             intercept     => $intercept,
							                                 maxBPspan     => $maxBPspan,
							                                 noLonelyPairs => $noLonelyPairs,
                                                             noClosingGU   => $noClosingGU,
                                                             temperature   => $temperature,
                                                             winSize       => $foldWin,
                                                             offset        => $foldOffset,
                                                             winTrim       => $winTrim }) if ($foldQuery);

    ($querySeq, $queryReact) = rmEndNan($querySeq, $queryReact);

    next if (@{$queryReact} < $kmerLen);

    $kmerLookupCmd = $Bin . "/swKmerLookup --seq " . $querySeq . " --react " . join(",", @{$queryReact}) . " --threads " . $threads .
                     " --minKmers " . $minKmers . " --maxReactivity " . $maxReactivity . " --maxKmerDist " . $maxKmerDist .
                     " --kmerMaxSeqDist " . $kmerMaxSeqDist . " --kmerLen " . $kmerLen . " --kmerOffset " . $kmerOffset .
                     " --kmerMinComplexity " . $kmerMinComplexity . " --kmerMaxMatchEveryNt " . $kmerMaxMatchEveryNt;
    $kmerLookupCmd .= " --matchKmerSeq" if ($matchKmerSeq);
    $kmerLookupCmd .= " --matchKmerGCcontent" if ($matchKmerGCcontent);
    $kmerLookupCmd .= " --maxKmerGCdiff " . $maxKmerGCdiff if (defined $maxKmerGCdiff && $matchKmerGCcontent);

    $dbIO = SW::DB->new( file  => $dbFolder . "reactivity.db",
                         index => $dbFolder . "reactivity.dbi");

    $progressBar->max(1);
    $progressBar->reset();
    $progressBar->init("Kmer lookup query \"" . $queryId . "\"");

    $ret = `$kmerLookupCmd --db ${dbFolder}reactivity.db --output ${output}tmp/$queryId.kmers`;

    $progressBar->update(1);
    print "\n";

    if (-e $output . "tmp/" . $queryId . ".kmers") {

        my $kmers = retrieve($output . "tmp/" . $queryId . ".kmers");
        @kmers = @{$kmers};

        unlink($output . "tmp/" . $queryId . ".kmers");

    }

    next if (!@kmers);

    $nKmers = @kmers;
    $progressBar->max($nKmers);
    $progressBar->reset();
    $progressBar->init("Alignment");

    @pool = map { threads->create(\&align, $querySeq, $queryReact,
                                           [ splice(@kmers, 0, min(max(POSIX::ceil($nKmers / $threads), 1), scalar(@kmers))) ]) } 1 .. $threads;
    @alignments = sort {$b->score() <=> $a->score()} grep { defined $_ } map { @{$_->join()} } @pool;
    $n = @alignments;
    ($nullMean, $nullStdev, $nullModel) = nullModelStats([map {$_->score} @alignments], 5);

    if (@{$nullModel} < $nullKmers) {

        print "\n";

        $dbIO = SW::DB->new( file  => $dbFolder . "reactivity.shuffled.db",
                             index => $dbFolder . "reactivity.shuffled.dbi");
        $processedNullKmers = @{$nullModel};

        $progressBar->max(1);
        $progressBar->reset();
        $progressBar->init("Kmer lookup shuffled db");

        $ret = `$kmerLookupCmd --db ${dbFolder}reactivity.shuffled.db --output ${output}tmp/$queryId.kmers`;

        $progressBar->update(1);
        print "\n";

        if (-e $output . "tmp/" . $queryId . ".kmers") {

            my $kmers = retrieve($output . "tmp/" . $queryId . ".kmers");
            @kmers = @{$kmers};

            unlink($output . "tmp/" . $queryId . ".kmers");

        }

        if (@kmers) {

            $nKmers = min(scalar(@kmers), $nullKmers - scalar(@{$nullModel}));
            @kmers = (List::Util::shuffle(@kmers))[0 .. $nKmers - 1];
            $progressBar->max($nKmers);
            $progressBar->reset();
            $progressBar->init("Alignment shuffled db");

            @pool = map { threads->create(\&align, $querySeq, $queryReact,
                                                   [ splice(@kmers, 0, min(max(POSIX::ceil($nKmers / $threads), 1), scalar(@kmers))) ]) } 1 .. $threads;
            push(@{$nullModel}, map { $_->score() } grep { defined $_ } map { @{$_->join()} } @pool);
            ($nullMean, $nullStdev) = nullModelStats($nullModel);

        }

    }

    foreach my $aln (@alignments) {

        my ($pvalue, $evalue);
        $pvalue = calcPvalue($aln->score(), $nullMean, $nullStdev);
        $evalue = $pvalue * $n;

        if ($evalue < $reportEvalue) {

            $aln->queryId($queryId);
            $aln->pvalue($pvalue);
            $aln->evalue($evalue);
            push(@matches, $aln);

        }
        else { last; }

    }

    print "\n";

    @matches = cleanupAlignments(@matches);

    if (@matches) {

        if ($evalAlignFold) {

            $progressBar->max(scalar(@matches) * $nAliShufflings);
            $progressBar->reset();
            $progressBar->init("Folding alignment");

            for (my $i = 0; $i < @matches; $i++) {

                my ($match, $interface, $aln, $processManager, $dbBpSupport,
                    $queryBpSupport, $aliZscore, $aliPvalue, @nullEnergies,
                    @nullStats);
                $match = $matches[$i];
                $interface = Interface::ViennaRNA->new(RNAalifold => $pathToAlifold);
                $aln = $interface->alifold({ db => $match->dbSeq(), query => $match->querySeq() },
                                           { reactivity     => { db    => [ ($match->db())[$match->dbNonGaps()] ],
                                                                 query => [ ($match->query())[$match->queryNonGaps()] ] },
                                             slope          => $slope,
                                             intercept      => $intercept,
                                             ribosumScoring => $ribosumScoring,
					     maxBPspan      => $maxBPspan,
					     noLonelyPairs  => $noLonelyPairs });

                ($dbBpSupport, $queryBpSupport) = calcBpSupport($match->dbSeq(), $match->querySeq(), $aln->structure());

                $match->structure($aln->structure());
                $match->dbBpSupport($dbBpSupport);
                $match->queryBpSupport($queryBpSupport);

                if ($dbBpSupport >= $minBpSupport & $queryBpSupport >= $minBpSupport) {

                    # Faster than threads
                    $processManager = Core::Process::Queue->new( processors   => $threads,
                                                                 parentOnExit => sub { $progressBar->update(1); },
                                                                 tmpDir       => $output . "tmp/" );
                    $processManager->enqueue( command   => \&shuffleAlifold,
                                              arguments => [ $match ] ) for (1 .. $nAliShufflings);
                    $processManager->start();
                    $processManager->waitall();

                    while (my $process = $processManager->dequeue()) { push(@nullEnergies, $process->exitcode()->[0]); }

                    @nullStats = nullModelStats(\@nullEnergies);
                    $aliZscore = ($aln->energy() - $nullStats[0]) / $nullStats[1];
    	            $aliPvalue = $aliZscore > 0 ? 1 : pnorm($aliZscore);

                    $match->alignFoldPvalue($aliPvalue);

                }

            }

            print "\n";

        }

        foreach my $match (@matches) {

            my @match = ($match->queryId(), $match->dbId(), $match->queryStart(), $match->queryEnd(), $match->dbStart(),
                         $match->dbEnd(), join("-", $match->querySeed()), join("-", $match->dbSeed()), sprintf("%.2f", $match->score()),
                         formatPvalue($match->pvalue()), formatPvalue($match->evalue()));
            push(@match, formatPvalue($match->alignFoldPvalue()), sprintf("%.2f", $match->dbBpSupport()), sprintf("%.2f", $match->queryBpSupport())) if ($evalAlignFold);

            if ($match->evalue() < $inclusionEvalue) {

                next if ($evalAlignFold && ($match->dbBpSupport() < $minBpSupport || $match->queryBpSupport() < $minBpSupport || $match->alignFoldPvalue() > $alignFoldPvalue));

                makePlot($match) if ($makePlot);

                if ($reportAln) {

                    if ($reportAln =~ m/^f/i) { reportFastaAln($match); }
                    else { reportStockholmAln($match); }

                }

            }

            push(@finalMatches, \@match);

        }

    }

}
$queryIO->close();

print CLRTOP;

if (@finalMatches) {

    my ($resultTable, @head, @inc, @rep);
    $resultTable = Term::Table->new();
    @head = ("Query", "DB entry", "Qstart", "Qend", "Dstart", "Dend", "Qseed", "Dseed", "Score", "P-value", "E-value");
    push(@head, "Alifold p-value", "Dbpsupport", "Qbpsupport") if ($evalAlignFold);
    $resultTable->head(@head, "");

    @inc = sort { $a->[10] <=> $b->[10] ||
                  $a->[0] cmp $b->[0] } grep { $_->[10] < $inclusionEvalue } @finalMatches;
    @rep = sort { $a->[10] <=> $b->[10] ||
                  $a->[0] cmp $b->[0] } grep { $_->[10] >= $inclusionEvalue && $_->[10] < $reportEvalue } @finalMatches;

    if ($evalAlignFold) {

        @rep = (grep { $_->[11] > $alignFoldPvalue || $_->[12] < $minBpSupport || $_->[13] < $minBpSupport } @inc, @rep);
        @inc = grep { $_->[11] <= $alignFoldPvalue || $_->[12] >= $minBpSupport || $_->[13] >= $minBpSupport } @inc;

    }

    $resultTable->row(@$_, "!") for (@inc);
    $resultTable->blank() if (@inc && @rep);
    $resultTable->row(@$_, "?") for (@rep);

    $resultTable->print();

    print "\n\n";

    if ($tblOut) {

        my $io = Data::IO->new( file => $output . "results.out",
                                mode => "w" );
        $io->write(join("\t", @head) . "\n");
        $io->write(join("\t", @$_, "!") . "\n") for (@inc);
        $io->write(join("\t", @$_, "?") . "\n") for (@rep);
        $io->close();

    }

}
else { die "\n[!] No significant match with current search parameters\n\n"; }

rmtree($output . "tmp/");

sub reportFastaAln {

    my $aln = shift;

    my $io = Data::IO->new( file => $output . "alignments/" . $aln->dbId() . "_" . join("-", $aln->dbStart(), $aln->dbEnd()) .
                                    "_" . $aln->queryId() . "_" . join("-", $aln->queryStart(), $aln->queryEnd()) . ".fasta",
                            mode => "w" );
    $io->write(">" . $aln->dbId() . "\n" . $aln->dbSeq() . "\n" .
               ">" . $aln->queryId() . "\n" . $aln->querySeq() . "\n");
    $io->close();

}

sub reportStockholmAln {

    my $aln = shift;

    my ($io, $id, $maxLen);
    $id = $aln->dbId() . "_" . join("-", $aln->dbStart(), $aln->dbEnd()) . "_" . $aln->queryId() . "_" . join("-", $aln->queryStart(), $aln->queryEnd());
    $io = Data::IO->new( file => $output . "alignments/" . $id . ".stockholm",
                            mode => "w" );
    $maxLen = max(length($aln->dbId()), length($aln->queryId()), 12) + 4; # 4 is the actual spacing
    $io->write("# STOCKHOLM 1.0\n" .
               "#=GF ID " . $id . "\n" .
               "#=GF AU SHAPEwarp " . $Core::Utils::VERSION . "\n\n" .
               $aln->dbId() . (" " x ($maxLen - length($aln->dbId()))) . $aln->dbSeq() . "\n" .
               $aln->queryId() . (" " x ($maxLen - length($aln->queryId()))) . $aln->querySeq() . "\n");
    $io->write("#=GC SS_cons" . (" " x ($maxLen - 12)) . $aln->structure() . "\n") if ($evalAlignFold);
    $io->write("//\n");
    $io->close();

}

sub makePlot {

    my $aln = shift;

    my ($io, $image, $length, $file,
        $dbReact, $dbRuler, $queryReact, $queryRuler,
        $minHeight, $maxHeight, $structure, @colors);
    $file = $output . "images/" . $aln->dbId() . "_" . join("-", $aln->dbStart(), $aln->dbEnd()) .
            "_" . $aln->queryId() . "_" . join("-", $aln->queryStart(), $aln->queryEnd()) . ".svg";
    $length = length($aln->dbSeq());
    $minHeight = $evalAlignFold ? 500 : 250;
    $maxHeight = $evalAlignFold ? 1000 : 500;
    $image = Graphics::Container->new( height  => abs(maprange(0, 1000, -$maxHeight, -$minHeight, min($length, 1000))),
                                       width   => 1000,
                                       spacing => 0.01 );
    $io = Data::IO->new( file    => $file,
                         mode    => "w",
                         binmode => ":encoding(utf-8)" );
    @colors = map { isnan($_) ? "white" : ($_ < 0.3 ? "black" : ($_ < 0.7 ? "rgb(255,204,0)" : "rgb(153,25,23)")) } $aln->db();
    $dbReact = Graphics::Object::Barplot->new( fontsize  => abs(maprange(0, 1000, -30, -10, min($length, 1000))), # Min: 10pt / Max: 30pt
                                               height    => 1,
                                               values    => [ map { isnumeric($_) ? min($_, 2) : "NaN" } $aln->db() ],
                                               yname     => "Reactivity",
                                               barfill   => \@colors,
                                               barstroke => \@colors );
    $dbRuler = Graphics::Object::Ruler->new( fontsize => abs(maprange(0, 1000, -30, -10, min($length, 1000))),
                                             height   => 1,
                                             range    => [0, $length - 1],
                                             labelMap => { "0"         => $aln->dbStart(),
                                                           $length - 1 => $aln->dbEnd() },
                                             name     => $aln->dbId() . " (Database)" );

    $image->addobjects($dbReact, $dbRuler);

    @colors = map { isnan($_) ? "white" : ($_ < 0.3 ? "black" : ($_ < 0.7 ? "rgb(255,204,0)" : "rgb(153,25,23)")) } $aln->query();
    $queryReact = Graphics::Object::Barplot->new( fontsize  => abs(maprange(0, 1000, -30, -10, min($length, 1000))), # Min: 10pt / Max: 30pt
                                                  height    => 1,
                                                  values    => [ map { isnumeric($_) ? min($_, 2) : "NaN" } $aln->query() ],
                                                  yname     => "Reactivity",
                                                  barfill   => \@colors,
                                                  barstroke => \@colors );
    $queryRuler = Graphics::Object::Ruler->new( fontsize => abs(maprange(0, 1000, -30, -10, min($length, 1000))),
                                                height   => 1,
                                                range    => [0, $length - 1],
                                                labelMap => { "0"         => $aln->queryStart(),
                                                              $length - 1 => $aln->queryEnd() },
                                                name     => $aln->queryId() . " (Query)" );

    $image->addobjects($queryReact, $queryRuler);

    if ($evalAlignFold) {

	my @pairs = listpairs($aln->structure());

	if (@pairs) {

            $structure = Graphics::Object::RNAarcs->new( height    => 2,
                                                         length    => $length,
                                                         flip      => "down",
                                                         basepairs => \@pairs );

            $image->addobject($structure);

	}

    }

    $io->write($image->xml());
    $io->close();

}

sub align {

    my $querySeq = shift;
    my $queryReact = shift;
    my @kmers = @{$_[0]};

    $dbIO->forceReopenFh();

    my ($lastId, $lastSeq, @lastReact, @alignments);

    while(my $kmer = shift(@kmers)) {

        my ($id, $aligner, $aln);
        $id = $kmer->{dbId};

        if ($id ne $lastId) {

            my $entry = $dbIO->read($id);
            $lastId = $id;
            $lastSeq = $entry->sequence();
            @lastReact = $entry->reactivity();

        }

        $aligner = SW::Align->new( db              => \@lastReact,
                                   dbSeq           => $lastSeq,
                                   query           => $queryReact,
                                   querySeq        => $querySeq,
                                   dbSeed          => $kmer->{db},
                                   querySeed       => $kmer->{query},
                                   maxReactivity   => $maxReactivity,
                                   scoreSeq        => $alignScoreSeq,
                                   seqMatch        => $alignSeqMatchScore,
                                   seqMismatch     => $alignSeqMismatchScore,
                                   match           => $alignMatchScore,
                                   mismatch        => $alignMismatchScore,
                                   gapOpen         => $alignGapOpenPenal,
                                   gapExt          => $alignGapExtPenal,
                                   lenTolerance   => $alignLenTolerance,
                                   maxDropOffRate  => $alignMaxDropOffRate,
                                   maxDropOffBases => $alignMaxDropOffBases );
        $aln = $aligner->align();

        if ($aln) {

            # Updates the score with score adjusted by query coverage
            $aln->score($aln->score() * log(scalar($aln->query())) / log(length($querySeq)));# / log(scalar(@{$queryReact})));
            $aln->dbId($id);

            push(@alignments, $aln);

	}

        { lock($progressBar);
          $progressBar->update(1); }

    }

    return(\@alignments);

}

sub cleanupAlignments {

    my @alignments = sort { $a->dbId() cmp $b->dbId() } @_;

    for (my $i = 0; $i < @alignments; $i++) {

        my $aln1 = $alignments[$i];

        for (my $j = $i + 1; $j < @alignments; $j++) {

            my ($aln2, $overlap1, $overlap2);
            $aln2 = $alignments[$j];

            last if ($aln1->dbId() ne $aln2->dbId());

            $overlap1 = intersect([$aln1->dbStart(), $aln1->dbEnd()], [$aln2->dbStart(), $aln2->dbEnd()]);
            $overlap2 = intersect([$aln1->queryStart(), $aln1->queryEnd()], [$aln2->queryStart(), $aln2->queryEnd()]);

            if ($overlap1 && $overlap2 &&
                min(abs(diff(@{$overlap1})) / min(abs(diff($aln1->dbStart(), $aln1->dbEnd())), abs(diff($aln2->dbStart(), $aln2->dbEnd()))),
                    abs(diff(@{$overlap2})) / min(abs(diff($aln1->queryStart(), $aln1->queryEnd())), abs(diff($aln2->queryStart(), $aln2->queryEnd())))) >= $maxAlignOverlap) {

                if ($aln1->score() < $aln2->score()) {

                    $alignments[$i] = $alignments[$j];
                    $aln1 = $aln2;

                }

                splice(@alignments, $j, 1);
                $j--;

            }

        }

    }

    return(@alignments);

}

sub formatPvalue { return($_[0] < 0.01 ? sprintf("%.2e", $_[0]) : sprintf("%.2f", $_[0])); }

sub shuffleAlifold {

    my $match = shift;

    my ($interface, $alignment, $reactivity, $aln);
    $interface = Interface::ViennaRNA->new();
    ($alignment, $reactivity) = _shuffleAlignment($match);
    $aln = $interface->alifold($alignment, { reactivity     => $reactivity,
                                             slope          => $slope,
                                             intercept      => $intercept,
					     maxBPspan      => $maxBPspan,
					     noLonelyPairs  => $noLonelyPairs,
                                             ribosumScoring => $ribosumScoring });

    return($aln->energy());

}

sub _shuffleAlignment {

    my $match = shift;

    my ($n, $starti, $iSize, @i, @db, @query, @dbSeq,
        @querySeq, %alignment, %reactivity);
    @db = $match->db();
    @query = $match->query();
    @dbSeq = split("", $match->dbSeq());
    @querySeq = split("", $match->querySeq());
    $starti = int(rand($blockSize));

    for (my $i = $starti; $i < @dbSeq - $blockSize; $i += $blockSize) { push(@i, [ $inBlockShuffle ? List::Util::shuffle($i .. $i + $blockSize - 1) : $i .. $i + $blockSize - 1 ]); }

    unshift(@i, [ $inBlockShuffle ? List::Util::shuffle(0 .. $starti - 1) : 0 .. $starti - 1 ]) if ($starti);
    $iSize = scalar(map { @{$_} } @i) - 1;
    push(@i, [ $inBlockShuffle ? List::Util::shuffle($iSize + 1 .. $#dbSeq) : $iSize + 1 .. $#dbSeq ]) if ($iSize < $#dbSeq);

    @i = map { @{$_} } List::Util::shuffle(@i);

    %alignment = ( db    => join("", @dbSeq[@i]),
                   query => join("", @querySeq[@i]) );
    %reactivity = ( db    => [ @db[uniq(map { my $i = $_; $i - scalar(grep {$_ < $i} $match->dbGaps()) } @i)] ],
                    query => [ @query[uniq(map { my $i = $_; $i - scalar(grep {$_ < $i} $match->queryGaps()) } @i)] ] );

    return(\%alignment, \%reactivity);

}

sub calcBpSupport {

    my ($dbSeq, $querySeq, $structure) = @_;

    my ($dbPairs, $queryPairs, @pairs);
    @pairs = listpairs($structure);

    return(0, 0) if (!@pairs);

    $dbPairs = (rmnoncanonical($dbSeq, \@pairs))[0];
    $queryPairs = (rmnoncanonical($querySeq, \@pairs))[0];

    return(@$dbPairs / @pairs, @$queryPairs / @pairs);

}

sub writeParamsOut {

    my $paramIO = Data::IO->new( file => $output . "params.out",
                                 mode => "w" );
    $paramIO->write("db=$dbFolder\n" .
                    "query=$queryFile\n" .
                    "foldQuery=" . ($foldQuery ? "yes" : "no") . "\n" .
                    ($foldQuery ? "slope=$slope\n" .
                                  "intercept=$intercept\n" : undef) .
                    "kmerLen=$kmerLen\n" .
                    "kmerOffset=$kmerOffset\n" .
                    "minKmers=$minKmers\n" .
                    "maxKmerDist=$maxKmerDist\n" .
                    "kmerMinComplexity=$kmerMinComplexity\n" .
                    "kmerMaxMatchEveryNt=$kmerMaxMatchEveryNt\n" .
                    "matchKmerSeq=" . ($matchKmerSeq ? "yes" : "no") . "\n" .
                    ($matchKmerSeq ? "kmerMaxSeqDist=$kmerMaxSeqDist\n" : undef) .
                    "matchKmerGCcontent=" . ($matchKmerGCcontent ? "yes" : "no") . "\n" .
                    ($matchKmerGCcontent && $maxKmerGCdiff ? "maxKmerGCdiff=$maxKmerGCdiff\n" : undef) .
                    "nullKmers=$nullKmers\n" .
                    "alignMatchScore=" . join(",", @$alignMatchScore) . "\n" .
                    "alignMismatchScore=" . join(",", @$alignMismatchScore) . "\n" .
                    "alignGapOpenPenal=$alignGapOpenPenal\n" .
                    "alignGapExtPenal=$alignGapExtPenal\n" .
                    "alignMaxDropOffRate=$alignMaxDropOffRate\n" .
                    "alignMaxDropOffBases=$alignMaxDropOffBases\n" .
                    "alignLenTolerance=$alignLenTolerance\n" .
                    "alignScoreSeq=" . ($alignScoreSeq ? "yes" : "no") . "\n" .
                    ($alignScoreSeq ? "alignSeqMatchScore=$alignSeqMatchScore\n" .
                                      "alignSeqMismatchScore=$alignSeqMismatchScore\n" : undef) .
                    "maxReactivity=$maxReactivity\n" .
                    "maxAlignOverlap=$maxAlignOverlap\n" .
                    "evalAlignFold=" . ($evalAlignFold ? "yes" : "no") . "\n" .
                    ($evalAlignFold ? "alignFoldPvalue=$alignFoldPvalue\n" .
                                      "minBpSupport=$minBpSupport\n" .
                                      "ribosumScoring=" . ($ribosumScoring ? "yes" : "no") . "\n" .
                                      "blockSize=$blockSize\n" .
                                      "inBlockShuffle=" . ($inBlockShuffle ? "yes" : "no") . "\n" : undef) .
                    "inclusionEvalue=$inclusionEvalue\n" .
                    "reportEvalue=$reportEvalue\n");

    $paramIO->close();

}

sub rmEndNan {

    my @sequence = split(//, $_[0]);
    my @reactivity = @{$_[1]};

    while(isnan($reactivity[0])) {

        shift(@reactivity);
        shift(@sequence);

    }

    while(isnan($reactivity[-1])) {

        pop(@reactivity);
        pop(@sequence);

    }

    return(join("", @sequence), \@reactivity);

}

sub help {

    print "\n  [!] Error: Invalid option. Please check the help\n" if ($_[0]);

    die <<HELP;

 SHAPEwarp (v1.0.0a)

 Authors: Edoardo Morandi (emorandi[at]rnaframework.com)
          Danny Incarnato (dincarnato[at]rnaframework.com)
 Summary: SHAPE-guided RNA structural homology search

 Usage:   SHAPEwarp [Options] --query query.txt

 Options                                         Description
 -db or --database             <string>          Path to a database folder generated with swBuildDb
 -q  or --query                <string>          Path to the query file
                                                 Note: each entry should contain (one per row) the sequence id, the nucleotide sequence and
                                                       a comma-separated list of SHAPE reactivities, one per
 -o  or --output               <string>          Output directory (Default: sw_out/)
 -ow or --overwrite                              Overwrites the output directory (if the specified path already exists)
 --threads                     <int>             Number of processors to use (Default: 1)
 --maxReactivity               <float>           Maximum value to which reactivities will be capped (Default: 1)
 --maxAlignOverlap             <float>           If two significant alignments overlap by more than this value, the least significant one
                                                 (the one with the lowest alignment score) will be discarded (Default: 0.5)
 --nullKmers                   <int>             Number of kmer matches to be extended to build the null model (Default: 10000)
 --incE or --inclusionEvalue   <float>           E-value threshold to consider an alignment significant (Default: 0.01)
 --repE or --reportEvalue      <float>           E-value threashold to report a match (Default: 0.1)
 --makePlot                                      Generates plots of aligned SHAPE reactivity (or probability) profiles
                                                 Note: plots are generated only for matches below the inclusion E-value cutoff
 --reportAln                   <string>          Reports sequence alignments in the specified format ([f]asta or [s]tockholm)
                                                 Note: alignments are reported only for matches below the inclusion E-value cutoff
 --foldQuery                                     Query SHAPE profile is first used to calculate a base-pairing probability profile,
                                                 that is then used to search into the db
                                                 Note: the db must have been generated with the --foldDb option

 |
 +- Folding options (require --foldQuery or --evalAlignFold)

    --slope                    <float>           Slope for SHAPE reactivities conversion into pseudo-free energy contributions (Default: 1.8)
    --intercept                <float>           Intercept for SHAPE reactivities conversion into pseudo-free energy contributions (Default: -0.6)
    --maxBPspan                <int>             Maximum allowed base-pairing distance (Default: 600)
    --noLonelyPairs                              Disallows lonely pairs (helices of 1 bp)
    --noClosingGU                                Dissalows G:U wobbles at the end of helices
    --temperature              <float>           Folding temperature (Default: 37)

    |
    +- Query folding-specific options (require --foldQuery)

       --winSize               <int>             Size (in nt) of the sliding window for partition function calculation (Default: 800)
       --offset                <int>             Offset (in nt) for partition function window sliding (Default: 200)
       --winTrim               <int>             Number of bases to trim from both ends of partition function windows to avoid terminal
                                                 biases (Default: 50)
       --ignoreReact                             SHAPE reactivity is ignored when folding the query

 |
 +- Kmer lookup options

    --minKmers                 <int>             Minimum number of kmers required to form a High Scoring Group (HSG; Default: 2)
    --maxKmerDist              <int>             Maximum distance between two kmers to be merged in a HSG (Default: 30)
    --kmerLen                  <int>             Length (in nt) of the kmers (Default: 15)
    --kmerOffset               <int>             Sliding offset for extracting candidate kmers from the query (Default: 1)
    --matchKmerGCcontent                         The sequence of a query kmer and the corresponding database match must have GC% contents
                                                 differing no more than --maxKmerGCdiff
    --maxKmerGCdiff            <float>           Maximum allowed GC% difference to retain a kmer match (requires --matchKmerGCcontent)
                                                 Note: the default value is automatically determined based on the chosen kmer length
    --matchKmerSeq                               The sequence of a query kmer and the corresponding database match must differ no more
                                                 than --maxKmerSeqDist
    --maxKmerSeqDist           <float>           Maximum allowed sequence distance to retain a kmer match (requires --matchKmerSeq; Default: 0)
                                                 Note: when >= 1, this is interpreted as the absolute number of bases that are allowed to
                                                       differ between the kmer and the matching region. When < 1, this is interpreted as a
                                                       fraction of the kmer's length
    --kmerMinComplexity        <float>           Minimum complexity (measured as Gini coefficient) of candidate kmers (Default: 0.3)
    --kmerMaxMatchEveryNt      <int>             A kmer is allowed to match a database entry on average every this many nt (Default: 200)

 |
 +- Alignment options

    --alignMatchScore          <float>,<float>   Minimum and maximum score reactivity differences below 0.5 will be mapped to (Default: 0,2)
    --alignMismatchScore       <float>,<float>   Minimum and maximum score reactivity differences above 0.5 will be mapped to (Default: -6,-0.5)
    --alignGapOpenPenal        <float>           Gap open penalty (Default: -14)
    --alignGapExtPenal         <float>           Gap extension penalty (Default: -5)
    --alignMaxDropOffRate      <float>           An alignment is allowed to drop by maximum this fraction of the best score encountered so far,
                                                 before extension is interrupted (Default: 0.8)
    --alignMaxDropOffBases     <int>             An alignment is allowed to drop below the best score encountered so far * --alignMaxDropOffRate
                                                 by this number of bases, before extension is interrupted (Default: 8)
    --alignLenTolerance       <float>           The maximum allowed tollerated length difference between the query and db sequences to look for
                                                 the ideal alignment along the diagonal (measured as a fraction of the length of the shortest
                                                 sequence between the db and the query) (Default: 0.1)
                                                 Note: a minimum band size of 10 nt is always granted to perform the banded alignment
    --alignScoreSeq                              Sequence matches are rewarded during the alignment
    --alignSeqMatchScore       <float>           Score reward for matching bases (Default: 0.5)
    --alignSeqMismatchScore    <float>           Score penalty for mismatching bases (Default: -2)

 |
 +- Alignment folding evaluation options (see also "Folding options")

    --evalAlignFold                              Alignments passing the --inclusionEvalue threshold, are further evaluated for the presence of
                                                 a conserved RNA structure by using RNAalifold
    --blockSize                        <int>     Size (in nt) of the blocks for shuffling the alignment (Default: 3)
    --inBlockShuffle                             Besides shuffling blocks, residues within each block will be shuffled as well
    --minBpSupport                     <float>   Minimum fraction of base-pairs of the RNAalifold-inferred structure that should be supported
                                                 by both query and db sequence to retain a match (Default: 0.75)
    --ribosumScoring                             Use RIBOSUM scoring matrix
    --alignFoldPvalue                  <float>   P-value threshold to consider signficant an RNA structure predicted by RNAalifold (Default: 0.05)
    --RNAalifold                       <string>  Path to RNAalifold executable (Default: assumes RNAalifold is in PATH)

HELP

}
